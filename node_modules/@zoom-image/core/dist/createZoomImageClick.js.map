{"version":3,"sources":["../src/createZoomImageClick.ts","../src/imageLoader.ts","../src/utils.ts"],"names":["controller","signal"],"mappings":"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","sourcesContent":["import { createStore } from \"@namnode/store\"\nimport { imageLoader } from \"./imageLoader\"\nimport { ZoomedImgStatus } from \"./types\"\nimport { disableScroll, enableScroll, getSourceImage, noop } from \"./utils\"\n\nexport type ZoomImageClickOptions = {\n  zoomFactor?: number\n  zoomImageSource?: string\n  disableScrollLock?: boolean\n  zoomImageProps?: {\n    alt?: string\n  }\n}\n\nexport type ZoomImageClickState = {\n  zoomedImgStatus: ZoomedImgStatus\n}\n\nexport function createZoomImageClick(container: HTMLElement, options: ZoomImageClickOptions = {}) {\n  const sourceImgElement = getSourceImage(container)\n  const finalOptions: Omit<Required<ZoomImageClickOptions>, \"zoomImageProps\"> = {\n    zoomFactor: options.zoomFactor ?? 4,\n    zoomImageSource: options.zoomImageSource ?? sourceImgElement.src,\n    disableScrollLock: options.disableScrollLock ?? false,\n  }\n\n  const { zoomFactor, zoomImageSource, disableScrollLock } = finalOptions\n\n  let isOnMove = false\n\n  const store = createStore<ZoomImageClickState>({\n    zoomedImgStatus: \"idle\",\n  })\n\n  const zoomedImgWidth = sourceImgElement.clientWidth * zoomFactor\n  const zoomedImgHeight = sourceImgElement.clientHeight * zoomFactor\n  const zoomedImg = container.appendChild(document.createElement(\"img\"))\n  zoomedImg.alt = options.zoomImageProps?.alt || \"\"\n  zoomedImg.style.maxWidth = \"none\"\n  zoomedImg.style.display = \"none\"\n  zoomedImg.style.width = `${zoomedImgWidth}px`\n  zoomedImg.style.height = `${zoomedImgHeight}px`\n  zoomedImg.style.position = \"absolute\"\n  zoomedImg.style.top = \"0\"\n  zoomedImg.style.left = \"0\"\n\n  function handlePointerMove(event: PointerEvent) {\n    if (!isOnMove) {\n      return\n    }\n\n    processZoom(event)\n  }\n\n  const calculatePositionX = (newPositionX: number) => {\n    const width = container.clientWidth\n    if (newPositionX > 0) return 0\n    if (newPositionX + width * zoomFactor < width) return -width * (zoomFactor - 1)\n    return newPositionX\n  }\n\n  const calculatePositionY = (newPositionY: number) => {\n    const height = container.clientHeight\n    if (newPositionY > 0) return 0\n    if (newPositionY + height * zoomFactor < height) return -height * (zoomFactor - 1)\n    return newPositionY\n  }\n\n  function processZoom(event: PointerEvent) {\n    zoomedImg.style.display = \"block\"\n    imageLoader.createZoomImage(zoomedImg, zoomImageSource, store)\n\n    const containerRect = container.getBoundingClientRect()\n    const zoomPointX = event.clientX - containerRect.left\n    const zoomPointY = event.clientY - containerRect.top\n\n    const currentPositionX = calculatePositionX(-zoomPointX * zoomFactor + zoomPointX)\n    const currentPositionY = calculatePositionY(-zoomPointY * zoomFactor + zoomPointY)\n\n    zoomedImg.style.transform = `translate(${currentPositionX}px, ${currentPositionY}px)`\n  }\n\n  function handlePointerDown(event: PointerEvent) {\n    if (isOnMove) {\n      isOnMove = false\n      zoomedImg.style.display = \"none\"\n      return\n    }\n\n    processZoom(event)\n    isOnMove = true\n  }\n\n  const controller = new AbortController()\n  const { signal } = controller\n  container.addEventListener(\"pointerdown\", handlePointerDown, { signal })\n  container.addEventListener(\"pointerenter\", disableScrollLock ? noop : disableScroll, { signal })\n  container.addEventListener(\"pointerleave\", disableScrollLock ? noop : enableScroll, { signal })\n  container.addEventListener(\"pointermove\", handlePointerMove, { signal })\n  container.addEventListener(\"touchend\", enableScroll, { signal })\n\n  return {\n    cleanup: () => {\n      controller.abort()\n      container.contains(zoomedImg) && container.removeChild(zoomedImg)\n      store.cleanup()\n    },\n    subscribe: store.subscribe,\n    getState: store.getState,\n  }\n}\n","import { createStore } from \"@namnode/store\"\nimport { ZoomedImgStatus } from \"./types\"\n\n// There is a scenario where the image is already in the cache,\n// we don't want to trigger the loading state too quickly in that case\n// 50ms should be enough to wait before triggering the loading state\nconst THRESHOLD = 50\n\nexport const makeImageLoader = () => {\n  const createZoomImage = (\n    img: HTMLImageElement,\n    src: string,\n    store: ReturnType<\n      typeof createStore<{\n        zoomedImgStatus: ZoomedImgStatus\n      }>\n    >,\n  ) => {\n    if (img.src === src) return\n    img.src = src\n    let complete = false\n\n    img.onload = () => {\n      complete = true\n      store.setState({ zoomedImgStatus: \"loaded\" })\n    }\n\n    img.onerror = () => {\n      complete = true\n      store.setState({ zoomedImgStatus: \"error\" })\n    }\n\n    setTimeout(() => {\n      if (!complete) store.setState({ zoomedImgStatus: \"loading\" })\n    }, THRESHOLD)\n  }\n\n  return {\n    createZoomImage,\n  }\n}\n\nexport const imageLoader = makeImageLoader()\n","export function clamp(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value))\n}\n\nexport function noop() {}\n\nfunction preventDefault(event: Event) {\n  event.preventDefault()\n}\n\nconst keySet = new Set([\"ArrowUp\", \"ArrowRight\", \"ArrowDown\", \"ArrowLeft\"])\nfunction preventDefaultForScrollKeys(event: KeyboardEvent) {\n  if (keySet.has(event.key)) {\n    preventDefault(event)\n    return false\n  }\n}\n\nconst controller = new AbortController()\nconst signal = controller.signal\n\nexport function disableScroll() {\n  window.addEventListener(\"DOMMouseScroll\", preventDefault, { signal })\n  window.addEventListener(\"wheel\", preventDefault, { passive: false, signal })\n  window.addEventListener(\"touchmove\", preventDefault, { passive: false, signal })\n  window.addEventListener(\"keydown\", preventDefaultForScrollKeys, { signal })\n}\n\nexport function enableScroll() {\n  controller?.abort()\n}\n\nexport function getSourceImage(container: HTMLElement) {\n  if (!container) {\n    throw new Error(\"Please specify a container for the zoom image\")\n  }\n\n  const sourceImgElement = container.querySelector(\"img\")\n  if (!sourceImgElement) {\n    throw new Error(\"Please place an image inside the container\")\n  }\n\n  return sourceImgElement\n}\n\nexport type PointerPosition = {\n  x: number\n  y: number\n}\n\nexport function getPointersCenter(first: PointerPosition, second: PointerPosition) {\n  return {\n    x: (first.x + second.x) / 2,\n    y: (first.y + second.y) / 2,\n  }\n}\n\n// Given the previous and current positions of two touch inputs, compute the zoom\n// factor and the origin of the zoom gesture.\nexport function computeZoomGesture(prev: [PointerPosition, PointerPosition], curr: [PointerPosition, PointerPosition]) {\n  const prevCenter = getPointersCenter(prev[0], prev[1])\n  const currCenter = getPointersCenter(curr[0], curr[1])\n  const centerDist = { x: currCenter.x - prevCenter.x, y: currCenter.y - prevCenter.y }\n\n  const prevDistance = Math.hypot(prev[0].x - prev[1].x, prev[0].y - prev[1].y)\n  const currDistance = Math.hypot(curr[0].x - curr[1].x, curr[0].y - curr[1].y)\n  let scale = currDistance / prevDistance\n\n  // avoid division by zero\n  const eps = 0.00001\n  if (Math.abs(scale - 1) < eps) {\n    scale = 1 + eps\n  }\n\n  return {\n    scale,\n    center: {\n      // We shift the zoom center away such that the translation part of the gesture\n      // is also captured by the zoom operation.\n      x: prevCenter.x + centerDist.x / (1 - scale),\n      y: prevCenter.y + centerDist.y / (1 - scale),\n    },\n  }\n}\n\nexport function makeMaybeCallFunction<T>(predicateFn: () => boolean, fn: (arg: T) => void) {\n  return (arg: T) => {\n    if (predicateFn()) {\n      fn(arg)\n    }\n  }\n}\n\nexport const scaleLinear =\n  ({\n    domainStart,\n    domainStop,\n    rangeStart,\n    rangeStop,\n  }: {\n    domainStart: number\n    domainStop: number\n    rangeStart: number\n    rangeStop: number\n  }) =>\n  (value: number) =>\n    rangeStart + (rangeStop - rangeStart) * ((value - domainStart) / (domainStop - domainStart))\n"]}