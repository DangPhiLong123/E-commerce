// src/utils.ts
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function noop() {
}
function preventDefault(event) {
  event.preventDefault();
}
var keySet = /* @__PURE__ */ new Set(["ArrowUp", "ArrowRight", "ArrowDown", "ArrowLeft"]);
function preventDefaultForScrollKeys(event) {
  if (keySet.has(event.key)) {
    preventDefault(event);
    return false;
  }
}
var controller = new AbortController();
var signal = controller.signal;
function disableScroll() {
  window.addEventListener("DOMMouseScroll", preventDefault, { signal });
  window.addEventListener("wheel", preventDefault, { passive: false, signal });
  window.addEventListener("touchmove", preventDefault, { passive: false, signal });
  window.addEventListener("keydown", preventDefaultForScrollKeys, { signal });
}
function enableScroll() {
  controller?.abort();
}
function getSourceImage(container) {
  if (!container) {
    throw new Error("Please specify a container for the zoom image");
  }
  const sourceImgElement = container.querySelector("img");
  if (!sourceImgElement) {
    throw new Error("Please place an image inside the container");
  }
  return sourceImgElement;
}
function getPointersCenter(first, second) {
  return {
    x: (first.x + second.x) / 2,
    y: (first.y + second.y) / 2
  };
}
function computeZoomGesture(prev, curr) {
  const prevCenter = getPointersCenter(prev[0], prev[1]);
  const currCenter = getPointersCenter(curr[0], curr[1]);
  const centerDist = { x: currCenter.x - prevCenter.x, y: currCenter.y - prevCenter.y };
  const prevDistance = Math.hypot(prev[0].x - prev[1].x, prev[0].y - prev[1].y);
  const currDistance = Math.hypot(curr[0].x - curr[1].x, curr[0].y - curr[1].y);
  let scale = currDistance / prevDistance;
  const eps = 1e-5;
  if (Math.abs(scale - 1) < eps) {
    scale = 1 + eps;
  }
  return {
    scale,
    center: {
      // We shift the zoom center away such that the translation part of the gesture
      // is also captured by the zoom operation.
      x: prevCenter.x + centerDist.x / (1 - scale),
      y: prevCenter.y + centerDist.y / (1 - scale)
    }
  };
}
function makeMaybeCallFunction(predicateFn, fn) {
  return (arg) => {
    if (predicateFn()) {
      fn(arg);
    }
  };
}
var scaleLinear = ({
  domainStart,
  domainStop,
  rangeStart,
  rangeStop
}) => (value) => rangeStart + (rangeStop - rangeStart) * ((value - domainStart) / (domainStop - domainStart));

export { clamp, computeZoomGesture, disableScroll, enableScroll, getPointersCenter, getSourceImage, makeMaybeCallFunction, noop, scaleLinear };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=chunk-5KET5YPV.mjs.map