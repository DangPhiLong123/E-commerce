{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":";AAAO,SAAS,MAAM,OAAe,KAAa,KAAa;AAC7D,SAAO,KAAK,IAAI,KAAK,KAAK,IAAI,KAAK,KAAK,CAAC;AAC3C;AAEO,SAAS,OAAO;AAAC;AAExB,SAAS,eAAe,OAAc;AACpC,QAAM,eAAe;AACvB;AAEA,IAAM,SAAS,oBAAI,IAAI,CAAC,WAAW,cAAc,aAAa,WAAW,CAAC;AAC1E,SAAS,4BAA4B,OAAsB;AACzD,MAAI,OAAO,IAAI,MAAM,GAAG,GAAG;AACzB,mBAAe,KAAK;AACpB,WAAO;AAAA,EACT;AACF;AAEA,IAAM,aAAa,IAAI,gBAAgB;AACvC,IAAM,SAAS,WAAW;AAEnB,SAAS,gBAAgB;AAC9B,SAAO,iBAAiB,kBAAkB,gBAAgB,EAAE,OAAO,CAAC;AACpE,SAAO,iBAAiB,SAAS,gBAAgB,EAAE,SAAS,OAAO,OAAO,CAAC;AAC3E,SAAO,iBAAiB,aAAa,gBAAgB,EAAE,SAAS,OAAO,OAAO,CAAC;AAC/E,SAAO,iBAAiB,WAAW,6BAA6B,EAAE,OAAO,CAAC;AAC5E;AAEO,SAAS,eAAe;AAC7B,cAAY,MAAM;AACpB;AAEO,SAAS,eAAe,WAAwB;AACrD,MAAI,CAAC,WAAW;AACd,UAAM,IAAI,MAAM,+CAA+C;AAAA,EACjE;AAEA,QAAM,mBAAmB,UAAU,cAAc,KAAK;AACtD,MAAI,CAAC,kBAAkB;AACrB,UAAM,IAAI,MAAM,4CAA4C;AAAA,EAC9D;AAEA,SAAO;AACT;AAOO,SAAS,kBAAkB,OAAwB,QAAyB;AACjF,SAAO;AAAA,IACL,IAAI,MAAM,IAAI,OAAO,KAAK;AAAA,IAC1B,IAAI,MAAM,IAAI,OAAO,KAAK;AAAA,EAC5B;AACF;AAIO,SAAS,mBAAmB,MAA0C,MAA0C;AACrH,QAAM,aAAa,kBAAkB,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACrD,QAAM,aAAa,kBAAkB,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACrD,QAAM,aAAa,EAAE,GAAG,WAAW,IAAI,WAAW,GAAG,GAAG,WAAW,IAAI,WAAW,EAAE;AAEpF,QAAM,eAAe,KAAK,MAAM,KAAK,CAAC,EAAE,IAAI,KAAK,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE,IAAI,KAAK,CAAC,EAAE,CAAC;AAC5E,QAAM,eAAe,KAAK,MAAM,KAAK,CAAC,EAAE,IAAI,KAAK,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE,IAAI,KAAK,CAAC,EAAE,CAAC;AAC5E,MAAI,QAAQ,eAAe;AAG3B,QAAM,MAAM;AACZ,MAAI,KAAK,IAAI,QAAQ,CAAC,IAAI,KAAK;AAC7B,YAAQ,IAAI;AAAA,EACd;AAEA,SAAO;AAAA,IACL;AAAA,IACA,QAAQ;AAAA;AAAA;AAAA,MAGN,GAAG,WAAW,IAAI,WAAW,KAAK,IAAI;AAAA,MACtC,GAAG,WAAW,IAAI,WAAW,KAAK,IAAI;AAAA,IACxC;AAAA,EACF;AACF;AAEO,SAAS,sBAAyB,aAA4B,IAAsB;AACzF,SAAO,CAAC,QAAW;AACjB,QAAI,YAAY,GAAG;AACjB,SAAG,GAAG;AAAA,IACR;AAAA,EACF;AACF;AAEO,IAAM,cACX,CAAC;AAAA,EACC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAMA,CAAC,UACC,cAAc,YAAY,gBAAgB,QAAQ,gBAAgB,aAAa","sourcesContent":["export function clamp(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value))\n}\n\nexport function noop() {}\n\nfunction preventDefault(event: Event) {\n  event.preventDefault()\n}\n\nconst keySet = new Set([\"ArrowUp\", \"ArrowRight\", \"ArrowDown\", \"ArrowLeft\"])\nfunction preventDefaultForScrollKeys(event: KeyboardEvent) {\n  if (keySet.has(event.key)) {\n    preventDefault(event)\n    return false\n  }\n}\n\nconst controller = new AbortController()\nconst signal = controller.signal\n\nexport function disableScroll() {\n  window.addEventListener(\"DOMMouseScroll\", preventDefault, { signal })\n  window.addEventListener(\"wheel\", preventDefault, { passive: false, signal })\n  window.addEventListener(\"touchmove\", preventDefault, { passive: false, signal })\n  window.addEventListener(\"keydown\", preventDefaultForScrollKeys, { signal })\n}\n\nexport function enableScroll() {\n  controller?.abort()\n}\n\nexport function getSourceImage(container: HTMLElement) {\n  if (!container) {\n    throw new Error(\"Please specify a container for the zoom image\")\n  }\n\n  const sourceImgElement = container.querySelector(\"img\")\n  if (!sourceImgElement) {\n    throw new Error(\"Please place an image inside the container\")\n  }\n\n  return sourceImgElement\n}\n\nexport type PointerPosition = {\n  x: number\n  y: number\n}\n\nexport function getPointersCenter(first: PointerPosition, second: PointerPosition) {\n  return {\n    x: (first.x + second.x) / 2,\n    y: (first.y + second.y) / 2,\n  }\n}\n\n// Given the previous and current positions of two touch inputs, compute the zoom\n// factor and the origin of the zoom gesture.\nexport function computeZoomGesture(prev: [PointerPosition, PointerPosition], curr: [PointerPosition, PointerPosition]) {\n  const prevCenter = getPointersCenter(prev[0], prev[1])\n  const currCenter = getPointersCenter(curr[0], curr[1])\n  const centerDist = { x: currCenter.x - prevCenter.x, y: currCenter.y - prevCenter.y }\n\n  const prevDistance = Math.hypot(prev[0].x - prev[1].x, prev[0].y - prev[1].y)\n  const currDistance = Math.hypot(curr[0].x - curr[1].x, curr[0].y - curr[1].y)\n  let scale = currDistance / prevDistance\n\n  // avoid division by zero\n  const eps = 0.00001\n  if (Math.abs(scale - 1) < eps) {\n    scale = 1 + eps\n  }\n\n  return {\n    scale,\n    center: {\n      // We shift the zoom center away such that the translation part of the gesture\n      // is also captured by the zoom operation.\n      x: prevCenter.x + centerDist.x / (1 - scale),\n      y: prevCenter.y + centerDist.y / (1 - scale),\n    },\n  }\n}\n\nexport function makeMaybeCallFunction<T>(predicateFn: () => boolean, fn: (arg: T) => void) {\n  return (arg: T) => {\n    if (predicateFn()) {\n      fn(arg)\n    }\n  }\n}\n\nexport const scaleLinear =\n  ({\n    domainStart,\n    domainStop,\n    rangeStart,\n    rangeStop,\n  }: {\n    domainStart: number\n    domainStop: number\n    rangeStart: number\n    rangeStop: number\n  }) =>\n  (value: number) =>\n    rangeStart + (rangeStop - rangeStart) * ((value - domainStart) / (domainStop - domainStart))\n"]}