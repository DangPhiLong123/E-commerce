{"version":3,"sources":["../../../node_modules/.pnpm/@namnode+store@0.1.0/node_modules/@namnode/store/dist/chunk-TZNK2OF3.mjs","../src/imageLoader.ts","../src/utils.ts","../src/createZoomImageHover.ts"],"names":["controller","signal"],"mappings":"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","sourcesContent":["function f(o){let r=new Set,s=!1,a=o,e,c=(t={})=>{e={...e,...t},i();},i=()=>{if(s)return;let t=!1;if(e){for(let n in e)if(a[n]!==e[n]){t=!0;break}}t&&(a={...a,...e},r.forEach(n=>n({state:a,updatedProperties:e})),e=void 0);};return {subscribe:t=>(r.add(t),()=>{r.delete(t);}),cleanup:()=>r.clear(),getState:()=>a,setState:c,batch:t=>{s=!0,t(),s=!1,i();}}}\n\nexport { f as a };\n","import { createStore } from \"@namnode/store\"\nimport { ZoomedImgStatus } from \"./types\"\n\n// There is a scenario where the image is already in the cache,\n// we don't want to trigger the loading state too quickly in that case\n// 50ms should be enough to wait before triggering the loading state\nconst THRESHOLD = 50\n\nexport const makeImageLoader = () => {\n  const createZoomImage = (\n    img: HTMLImageElement,\n    src: string,\n    store: ReturnType<\n      typeof createStore<{\n        zoomedImgStatus: ZoomedImgStatus\n      }>\n    >,\n  ) => {\n    if (img.src === src) return\n    img.src = src\n    let complete = false\n\n    img.onload = () => {\n      complete = true\n      store.setState({ zoomedImgStatus: \"loaded\" })\n    }\n\n    img.onerror = () => {\n      complete = true\n      store.setState({ zoomedImgStatus: \"error\" })\n    }\n\n    setTimeout(() => {\n      if (!complete) store.setState({ zoomedImgStatus: \"loading\" })\n    }, THRESHOLD)\n  }\n\n  return {\n    createZoomImage,\n  }\n}\n\nexport const imageLoader = makeImageLoader()\n","export function clamp(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value))\n}\n\nexport function noop() {}\n\nfunction preventDefault(event: Event) {\n  event.preventDefault()\n}\n\nconst keySet = new Set([\"ArrowUp\", \"ArrowRight\", \"ArrowDown\", \"ArrowLeft\"])\nfunction preventDefaultForScrollKeys(event: KeyboardEvent) {\n  if (keySet.has(event.key)) {\n    preventDefault(event)\n    return false\n  }\n}\n\nconst controller = new AbortController()\nconst signal = controller.signal\n\nexport function disableScroll() {\n  window.addEventListener(\"DOMMouseScroll\", preventDefault, { signal })\n  window.addEventListener(\"wheel\", preventDefault, { passive: false, signal })\n  window.addEventListener(\"touchmove\", preventDefault, { passive: false, signal })\n  window.addEventListener(\"keydown\", preventDefaultForScrollKeys, { signal })\n}\n\nexport function enableScroll() {\n  controller?.abort()\n}\n\nexport function getSourceImage(container: HTMLElement) {\n  if (!container) {\n    throw new Error(\"Please specify a container for the zoom image\")\n  }\n\n  const sourceImgElement = container.querySelector(\"img\")\n  if (!sourceImgElement) {\n    throw new Error(\"Please place an image inside the container\")\n  }\n\n  return sourceImgElement\n}\n\nexport type PointerPosition = {\n  x: number\n  y: number\n}\n\nexport function getPointersCenter(first: PointerPosition, second: PointerPosition) {\n  return {\n    x: (first.x + second.x) / 2,\n    y: (first.y + second.y) / 2,\n  }\n}\n\n// Given the previous and current positions of two touch inputs, compute the zoom\n// factor and the origin of the zoom gesture.\nexport function computeZoomGesture(prev: [PointerPosition, PointerPosition], curr: [PointerPosition, PointerPosition]) {\n  const prevCenter = getPointersCenter(prev[0], prev[1])\n  const currCenter = getPointersCenter(curr[0], curr[1])\n  const centerDist = { x: currCenter.x - prevCenter.x, y: currCenter.y - prevCenter.y }\n\n  const prevDistance = Math.hypot(prev[0].x - prev[1].x, prev[0].y - prev[1].y)\n  const currDistance = Math.hypot(curr[0].x - curr[1].x, curr[0].y - curr[1].y)\n  let scale = currDistance / prevDistance\n\n  // avoid division by zero\n  const eps = 0.00001\n  if (Math.abs(scale - 1) < eps) {\n    scale = 1 + eps\n  }\n\n  return {\n    scale,\n    center: {\n      // We shift the zoom center away such that the translation part of the gesture\n      // is also captured by the zoom operation.\n      x: prevCenter.x + centerDist.x / (1 - scale),\n      y: prevCenter.y + centerDist.y / (1 - scale),\n    },\n  }\n}\n\nexport function makeMaybeCallFunction<T>(predicateFn: () => boolean, fn: (arg: T) => void) {\n  return (arg: T) => {\n    if (predicateFn()) {\n      fn(arg)\n    }\n  }\n}\n\nexport const scaleLinear =\n  ({\n    domainStart,\n    domainStop,\n    rangeStart,\n    rangeStop,\n  }: {\n    domainStart: number\n    domainStop: number\n    rangeStart: number\n    rangeStop: number\n  }) =>\n  (value: number) =>\n    rangeStart + (rangeStop - rangeStart) * ((value - domainStart) / (domainStop - domainStart))\n","import { createStore } from \"@namnode/store\"\nimport { imageLoader } from \"./imageLoader\"\nimport { ZoomedImgStatus } from \"./types\"\nimport { clamp, disableScroll, enableScroll, getSourceImage } from \"./utils\"\n\nexport type ZoomImageHoverOptions = {\n  customZoom: { width: number; height: number }\n  zoomImageSource?: string\n  zoomLensClass?: string\n  zoomLensScale?: number\n  zoomTarget: HTMLElement\n  zoomTargetClass?: string\n  scale?: number\n  disableScrollLock?: boolean\n  zoomImageProps?: {\n    alt?: string\n  }\n}\n\nexport type ZoomImageHoverState = {\n  zoomedImgStatus: ZoomedImgStatus\n  enabled: boolean\n}\n\nexport type ZoomImageHoverStateUpdate = { enabled: boolean }\n\nexport function createZoomImageHover(container: HTMLElement, options: ZoomImageHoverOptions) {\n  const controller = new AbortController()\n  const { signal } = controller\n  const sourceImgElement = getSourceImage(container)\n  const zoomedImgWrapper = document.createElement(\"div\")\n  zoomedImgWrapper.style.overflow = \"hidden\"\n  const zoomedImg = zoomedImgWrapper.appendChild(document.createElement(\"img\"))\n  zoomedImg.alt = options.zoomImageProps?.alt || \"\"\n  zoomedImg.style.maxWidth = \"none\"\n  zoomedImg.style.display = \"none\"\n  const zoomLens = container.appendChild(document.createElement(\"div\"))\n  zoomLens.style.display = \"none\"\n\n  // Sometimes, source image element's width and height are not available until the image is loaded\n  // and container size is set. These values are expected to be same as the container's width and height\n  let sourceImageElementWidth = 0\n  let sourceImageElementHeight = 0\n\n  const finalOptions: Omit<Required<ZoomImageHoverOptions>, \"zoomImageProps\"> = {\n    zoomImageSource: options.zoomImageSource || sourceImgElement.src,\n    zoomLensClass: options.zoomLensClass || \"\",\n    zoomTargetClass: options.zoomTargetClass || \"\",\n    customZoom: options.customZoom,\n    scale: options.scale || 2,\n    zoomTarget: options.zoomTarget,\n    zoomLensScale: options.zoomLensScale || 1,\n    disableScrollLock: options.disableScrollLock || false,\n  }\n\n  const {\n    scale,\n    zoomImageSource,\n    customZoom,\n    zoomLensClass,\n    zoomTarget,\n    zoomLensScale,\n    zoomTargetClass,\n    disableScrollLock,\n  } = finalOptions\n\n  const store = createStore<ZoomImageHoverState>({\n    zoomedImgStatus: \"idle\",\n    enabled: true,\n  })\n\n  let offset: { left: number; top: number } = getOffset(sourceImgElement)\n\n  function getOffset(element: HTMLElement) {\n    const elRect = element.getBoundingClientRect()\n    return { left: elRect.left, top: elRect.top }\n  }\n\n  function getLimitX(value: number) {\n    return sourceImageElementWidth - value\n  }\n\n  function getLimitY(value: number) {\n    return sourceImageElementHeight - value\n  }\n\n  function zoomLensLeft(left: number) {\n    const minX = zoomLens.clientWidth / 2\n    return clamp(left, minX, getLimitX(minX)) - minX\n  }\n\n  function zoomLensTop(top: number) {\n    const minY = zoomLens.clientHeight / 2\n    return clamp(top, minY, getLimitY(minY)) - minY\n  }\n\n  function processZoom(event: PointerEvent) {\n    let offsetX: number\n    let offsetY: number\n    let backgroundX: number\n    let backgroundY: number\n    if (offset) {\n      offsetX = zoomLensLeft(event.clientX - offset.left)\n      offsetY = zoomLensTop(event.clientY - offset.top)\n      backgroundX = (offsetX * scale) / zoomLensScale\n      backgroundY = (offsetY * scale) / zoomLensScale\n      zoomedImg.style.transform = \"translate(\" + -backgroundX + \"px,\" + -backgroundY + \"px)\"\n      zoomLens.style.cssText += \"transform:\" + \"translate(\" + offsetX + \"px,\" + offsetY + \"px);\"\n    }\n  }\n\n  async function handlePointerEnter() {\n    imageLoader.createZoomImage(zoomedImg, zoomImageSource, store)\n    zoomedImg.style.display = \"block\"\n    zoomLens.style.display = \"block\"\n\n    if (zoomTargetClass) {\n      const classes = zoomTargetClass.split(\" \")\n      classes.forEach((className) => zoomTarget.classList.add(className))\n    }\n\n    if (!disableScrollLock) disableScroll()\n  }\n\n  function handlePointerLeave() {\n    zoomedImg.style.display = \"none\"\n    zoomLens.style.display = \"none\"\n\n    if (zoomTargetClass) {\n      const classes = zoomTargetClass.split(\" \")\n      classes.forEach((className) => zoomTarget.classList.remove(className))\n    }\n\n    if (!disableScrollLock) enableScroll()\n  }\n\n  function handleScroll() {\n    offset = getOffset(sourceImgElement)\n  }\n\n  async function setup() {\n    if (zoomLensClass) {\n      zoomLens.className = zoomLensClass\n    } else {\n      zoomLens.style.background = \"rgba(238, 130, 238, 0.5)\"\n    }\n\n    // setup event listeners\n    container.addEventListener(\"pointerdown\", processZoom, { signal })\n    container.addEventListener(\"pointermove\", processZoom, { signal })\n    container.addEventListener(\"pointerenter\", handlePointerEnter, { signal })\n    container.addEventListener(\"pointerleave\", handlePointerLeave, { signal })\n    window.addEventListener(\"scroll\", handleScroll, { signal })\n    container.addEventListener(\"touchend\", enableScroll, { signal })\n\n    // Append zoomed image wrapper to zoom target\n    zoomTarget.appendChild(zoomedImgWrapper)\n\n    // Wait for next tick to get container size\n    await new Promise((resolve) => setTimeout(resolve, 1))\n    const containerRect = container.getBoundingClientRect()\n    sourceImageElementWidth = containerRect.width\n    sourceImageElementHeight = containerRect.height\n\n    // Set up styles if custom zoom available\n    if (customZoom) {\n      zoomedImgWrapper.style.width = customZoom.width + \"px\"\n      zoomedImgWrapper.style.height = customZoom.height + \"px\"\n    } else {\n      // Else default zoom to source image size\n      zoomedImgWrapper.style.width = sourceImageElementWidth + \"px\"\n      zoomedImgWrapper.style.height = sourceImageElementHeight + \"px\"\n    }\n\n    zoomedImg.width = (sourceImageElementWidth * scale) / zoomLensScale\n    zoomedImg.height = (sourceImageElementHeight * scale) / zoomLensScale\n\n    // Setup default zoom lens style\n    const sourceImageRect = sourceImgElement.getBoundingClientRect()\n    const fromLeft = sourceImageRect.left - containerRect.left\n    const fromTop = sourceImageRect.top - containerRect.top\n    zoomTarget.style.pointerEvents = \"none\"\n    zoomLens.style.position = \"absolute\"\n    zoomLens.style.left = fromLeft + \"px\"\n    zoomLens.style.top = fromTop + \"px\"\n    zoomLens.style.width = (customZoom.width / scale) * zoomLensScale + \"px\"\n    zoomLens.style.height = (customZoom.height / scale) * zoomLensScale + \"px\"\n  }\n\n  setup()\n\n  return {\n    cleanup: () => {\n      controller.abort()\n      container.contains(zoomLens) && container.removeChild(zoomLens)\n\n      if (zoomTarget && zoomTarget.contains(zoomedImgWrapper)) {\n        zoomTarget.removeChild(zoomedImgWrapper)\n        return\n      }\n\n      container.contains(zoomedImgWrapper) && container.removeChild(zoomedImgWrapper)\n    },\n    subscribe: store.subscribe,\n    getState: store.getState,\n    setState: (newState: ZoomImageHoverStateUpdate) => {\n      store.setState(newState)\n    },\n  }\n}\n"]}