'use strict';

var store = require('@namnode/store');

// src/createZoomImageMove.ts

// src/imageLoader.ts
var THRESHOLD = 50;
var makeImageLoader = () => {
  const createZoomImage = (img, src, store) => {
    if (img.src === src)
      return;
    img.src = src;
    let complete = false;
    img.onload = () => {
      complete = true;
      store.setState({ zoomedImgStatus: "loaded" });
    };
    img.onerror = () => {
      complete = true;
      store.setState({ zoomedImgStatus: "error" });
    };
    setTimeout(() => {
      if (!complete)
        store.setState({ zoomedImgStatus: "loading" });
    }, THRESHOLD);
  };
  return {
    createZoomImage
  };
};
var imageLoader = makeImageLoader();

// src/utils.ts
function preventDefault(event) {
  event.preventDefault();
}
var keySet = /* @__PURE__ */ new Set(["ArrowUp", "ArrowRight", "ArrowDown", "ArrowLeft"]);
function preventDefaultForScrollKeys(event) {
  if (keySet.has(event.key)) {
    preventDefault(event);
    return false;
  }
}
var controller = new AbortController();
var signal = controller.signal;
function disableScroll() {
  window.addEventListener("DOMMouseScroll", preventDefault, { signal });
  window.addEventListener("wheel", preventDefault, { passive: false, signal });
  window.addEventListener("touchmove", preventDefault, { passive: false, signal });
  window.addEventListener("keydown", preventDefaultForScrollKeys, { signal });
}
function enableScroll() {
  controller?.abort();
}
function getSourceImage(container) {
  if (!container) {
    throw new Error("Please specify a container for the zoom image");
  }
  const sourceImgElement = container.querySelector("img");
  if (!sourceImgElement) {
    throw new Error("Please place an image inside the container");
  }
  return sourceImgElement;
}

// src/createZoomImageMove.ts
function createZoomImageMove(container, options = {}) {
  let activePointerId = null;
  const sourceImgElement = getSourceImage(container);
  const finalOptions = {
    zoomFactor: options.zoomFactor ?? 4,
    zoomImageSource: options.zoomImageSource ?? sourceImgElement.src,
    disabledContextMenu: options.disabledContextMenu ?? false
  };
  const { disabledContextMenu, zoomFactor, zoomImageSource } = finalOptions;
  const store$1 = store.createStore({
    zoomedImgStatus: "idle"
  });
  const zoomedImg = document.createElement("img");
  options.zoomImageProps?.alt && (zoomedImg.alt = options.zoomImageProps.alt);
  options.zoomImageProps?.className && (zoomedImg.className = options.zoomImageProps.className);
  zoomedImg.style.maxWidth = "none";
  zoomedImg.style.position = "absolute";
  zoomedImg.style.top = "0";
  zoomedImg.style.left = "0";
  if (disabledContextMenu) {
    zoomedImg.style["-webkit-user-select"] = "none";
    zoomedImg.style["-webkit-touch-callout"] = "none";
    zoomedImg.oncontextmenu = () => false;
  }
  const checkValidPointer = (event) => {
    return activePointerId && event.pointerId === activePointerId;
  };
  function handlePointerEnter(event) {
    if (activePointerId === null) {
      activePointerId = event.pointerId;
      container.appendChild(zoomedImg);
      zoomedImg.style.display = "block";
      const zoomedImgWidth = sourceImgElement.clientWidth * zoomFactor;
      const zoomedImgHeight = sourceImgElement.clientHeight * zoomFactor;
      zoomedImg.style.width = `${zoomedImgWidth}px`;
      zoomedImg.style.height = `${zoomedImgHeight}px`;
      imageLoader.createZoomImage(zoomedImg, zoomImageSource, store$1);
      processZoom(event);
      event.pointerType !== "mouse" && disableScroll();
    }
  }
  function handlePointerMove(event) {
    if (checkValidPointer(event)) {
      processZoom(event);
    }
  }
  function resetZoomedImg(event) {
    if (checkValidPointer(event)) {
      container.contains(zoomedImg) && container.removeChild(zoomedImg);
      zoomedImg.style.display = "none";
      zoomedImg.style.transform = "none";
      enableScroll();
      activePointerId = null;
    }
  }
  const calculatePositionX = (newPositionX) => {
    const width = container.clientWidth;
    if (newPositionX > 0)
      return 0;
    if (newPositionX + width * zoomFactor < width)
      return -width * (zoomFactor - 1);
    return newPositionX;
  };
  const calculatePositionY = (newPositionY) => {
    const height = container.clientHeight;
    if (newPositionY > 0)
      return 0;
    if (newPositionY + height * zoomFactor < height)
      return -height * (zoomFactor - 1);
    return newPositionY;
  };
  function processZoom(event) {
    zoomedImg.style.display = "block";
    const containerRect = container.getBoundingClientRect();
    const zoomPointX = event.clientX - containerRect.left;
    const zoomPointY = event.clientY - containerRect.top;
    const currentPositionX = calculatePositionX(-zoomPointX * zoomFactor + zoomPointX);
    const currentPositionY = calculatePositionY(-zoomPointY * zoomFactor + zoomPointY);
    zoomedImg.style.transform = `translate(${currentPositionX}px, ${currentPositionY}px)`;
  }
  const controller2 = new AbortController();
  const { signal: signal2 } = controller2;
  container.addEventListener("pointerenter", handlePointerEnter, { signal: signal2 });
  container.addEventListener("pointermove", handlePointerMove, { signal: signal2 });
  container.addEventListener("pointerleave", resetZoomedImg, { signal: signal2 });
  container.addEventListener(
    "touchstart",
    (event) => {
      disabledContextMenu && event.preventDefault();
    },
    { signal: signal2 }
  );
  return {
    cleanup: () => {
      controller2.abort();
      container.contains(zoomedImg) && container.removeChild(zoomedImg);
      store$1.cleanup();
    },
    subscribe: store$1.subscribe,
    getState: store$1.getState
  };
}

exports.createZoomImageMove = createZoomImageMove;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=createZoomImageMove.js.map